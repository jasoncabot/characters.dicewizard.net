// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package store

import (
	"context"
	"strings"
	"time"
)

const checkInviteCodeExists = `-- name: CheckInviteCodeExists :one
SELECT 1 FROM campaign_invites WHERE code = ?
`

func (q *Queries) CheckInviteCodeExists(ctx context.Context, code string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkInviteCodeExists, code)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createCampaignHandout = `-- name: CreateCampaignHandout :one
INSERT INTO campaign_handouts (campaign_id, title, description, file_path, created_by)
VALUES (?, ?, ?, ?, ?)
RETURNING id, campaign_id, title, COALESCE(description, '') as description, COALESCE(file_path, '') as file_path, created_by, created_at, updated_at
`

type CreateCampaignHandoutParams struct {
	CampaignID  int64   `json:"campaignId"`
	Title       string  `json:"title"`
	Description *string `json:"description"`
	FilePath    *string `json:"filePath"`
	CreatedBy   int64   `json:"createdBy"`
}

type CreateCampaignHandoutRow struct {
	ID          int64     `json:"id"`
	CampaignID  int64     `json:"campaignId"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	FilePath    string    `json:"filePath"`
	CreatedBy   int64     `json:"createdBy"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

func (q *Queries) CreateCampaignHandout(ctx context.Context, arg CreateCampaignHandoutParams) (CreateCampaignHandoutRow, error) {
	row := q.db.QueryRowContext(ctx, createCampaignHandout,
		arg.CampaignID,
		arg.Title,
		arg.Description,
		arg.FilePath,
		arg.CreatedBy,
	)
	var i CreateCampaignHandoutRow
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Title,
		&i.Description,
		&i.FilePath,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMap = `-- name: CreateMap :one
INSERT INTO maps (scene_id, name, base_image_url)
VALUES (?, ?, ?)
RETURNING id, scene_id, name, COALESCE(base_image_url, '') as base_image_url, grid_size_ft, CAST(width_px AS INTEGER) as width_px, CAST(height_px AS INTEGER) as height_px, lighting_mode, fog_state, created_at
`

type CreateMapParams struct {
	SceneID      int64   `json:"sceneId"`
	Name         string  `json:"name"`
	BaseImageUrl *string `json:"baseImageUrl"`
}

type CreateMapRow struct {
	ID           int64     `json:"id"`
	SceneID      int64     `json:"sceneId"`
	Name         string    `json:"name"`
	BaseImageUrl string    `json:"baseImageUrl"`
	GridSizeFt   int64     `json:"gridSizeFt"`
	WidthPx      int64     `json:"widthPx"`
	HeightPx     int64     `json:"heightPx"`
	LightingMode string    `json:"lightingMode"`
	FogState     string    `json:"fogState"`
	CreatedAt    time.Time `json:"createdAt"`
}

// Map and Token queries
func (q *Queries) CreateMap(ctx context.Context, arg CreateMapParams) (CreateMapRow, error) {
	row := q.db.QueryRowContext(ctx, createMap, arg.SceneID, arg.Name, arg.BaseImageUrl)
	var i CreateMapRow
	err := row.Scan(
		&i.ID,
		&i.SceneID,
		&i.Name,
		&i.BaseImageUrl,
		&i.GridSizeFt,
		&i.WidthPx,
		&i.HeightPx,
		&i.LightingMode,
		&i.FogState,
		&i.CreatedAt,
	)
	return i, err
}

const createScene = `-- name: CreateScene :one
INSERT INTO scenes (campaign_id, name, description, ordering, is_active, created_by)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, campaign_id, name, COALESCE(description, '') as description, ordering, is_active, created_by, created_at, updated_at
`

type CreateSceneParams struct {
	CampaignID  int64   `json:"campaignId"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
	Ordering    int64   `json:"ordering"`
	IsActive    bool    `json:"isActive"`
	CreatedBy   *int64  `json:"createdBy"`
}

type CreateSceneRow struct {
	ID          int64     `json:"id"`
	CampaignID  int64     `json:"campaignId"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Ordering    int64     `json:"ordering"`
	IsActive    bool      `json:"isActive"`
	CreatedBy   *int64    `json:"createdBy"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

func (q *Queries) CreateScene(ctx context.Context, arg CreateSceneParams) (CreateSceneRow, error) {
	row := q.db.QueryRowContext(ctx, createScene,
		arg.CampaignID,
		arg.Name,
		arg.Description,
		arg.Ordering,
		arg.IsActive,
		arg.CreatedBy,
	)
	var i CreateSceneRow
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Name,
		&i.Description,
		&i.Ordering,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createToken = `-- name: CreateToken :one
INSERT INTO tokens (map_id, character_id, label, image_url, size_squares, position_x, position_y, facing_deg, audience, layer, tags, notes, created_by)
VALUES (?, ?10, ?, CAST(?11 AS TEXT), ?, ?, ?, ?, ?, ?, ?, '', ?12)
RETURNING id, map_id, character_id, label, COALESCE(image_url, '') as image_url, size_squares, position_x, position_y, facing_deg, audience, layer, tags, COALESCE(notes, '') as notes, created_by, created_at
`

type CreateTokenParams struct {
	MapID       int64  `json:"mapId"`
	CharacterID *int64 `json:"characterId"`
	Label       string `json:"label"`
	ImageUrl    string `json:"imageUrl"`
	SizeSquares int64  `json:"sizeSquares"`
	PositionX   int64  `json:"positionX"`
	PositionY   int64  `json:"positionY"`
	FacingDeg   int64  `json:"facingDeg"`
	Audience    string `json:"audience"`
	Layer       string `json:"layer"`
	Tags        string `json:"tags"`
	CreatedBy   *int64 `json:"createdBy"`
}

type CreateTokenRow struct {
	ID          int64     `json:"id"`
	MapID       int64     `json:"mapId"`
	CharacterID *int64    `json:"characterId"`
	Label       string    `json:"label"`
	ImageUrl    string    `json:"imageUrl"`
	SizeSquares int64     `json:"sizeSquares"`
	PositionX   int64     `json:"positionX"`
	PositionY   int64     `json:"positionY"`
	FacingDeg   int64     `json:"facingDeg"`
	Audience    string    `json:"audience"`
	Layer       string    `json:"layer"`
	Tags        string    `json:"tags"`
	Notes       string    `json:"notes"`
	CreatedBy   *int64    `json:"createdBy"`
	CreatedAt   time.Time `json:"createdAt"`
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (CreateTokenRow, error) {
	row := q.db.QueryRowContext(ctx, createToken,
		arg.MapID,
		arg.CharacterID,
		arg.Label,
		arg.ImageUrl,
		arg.SizeSquares,
		arg.PositionX,
		arg.PositionY,
		arg.FacingDeg,
		arg.Audience,
		arg.Layer,
		arg.Tags,
		arg.CreatedBy,
	)
	var i CreateTokenRow
	err := row.Scan(
		&i.ID,
		&i.MapID,
		&i.CharacterID,
		&i.Label,
		&i.ImageUrl,
		&i.SizeSquares,
		&i.PositionX,
		&i.PositionY,
		&i.FacingDeg,
		&i.Audience,
		&i.Layer,
		&i.Tags,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, password_hash)
VALUES (?, ?)
RETURNING id, username, password_hash, created_at
`

type CreateUserParams struct {
	Username     string `json:"username"`
	PasswordHash string `json:"passwordHash"`
}

// User queries
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCharacter = `-- name: DeleteCharacter :execrows
DELETE FROM characters WHERE id = ? AND user_id = ?
`

type DeleteCharacterParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"userId"`
}

func (q *Queries) DeleteCharacter(ctx context.Context, arg DeleteCharacterParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteCharacter, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getCampaignAndMapByToken = `-- name: GetCampaignAndMapByToken :one
SELECT sc.campaign_id, t.map_id
FROM tokens t
JOIN maps m ON m.id = t.map_id
JOIN scenes sc ON sc.id = m.scene_id
WHERE t.id = ?
`

type GetCampaignAndMapByTokenRow struct {
	CampaignID int64 `json:"campaignId"`
	MapID      int64 `json:"mapId"`
}

// Token helpers
func (q *Queries) GetCampaignAndMapByToken(ctx context.Context, id int64) (GetCampaignAndMapByTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getCampaignAndMapByToken, id)
	var i GetCampaignAndMapByTokenRow
	err := row.Scan(&i.CampaignID, &i.MapID)
	return i, err
}

const getCampaignByID = `-- name: GetCampaignByID :one
SELECT id, owner_id, name, COALESCE(description, '') as description, visibility, status, active_scene_id, created_at, updated_at
FROM campaigns
WHERE id = ?
`

type GetCampaignByIDRow struct {
	ID            int64     `json:"id"`
	OwnerID       int64     `json:"ownerId"`
	Name          string    `json:"name"`
	Description   string    `json:"description"`
	Visibility    string    `json:"visibility"`
	Status        string    `json:"status"`
	ActiveSceneID *int64    `json:"activeSceneId"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

func (q *Queries) GetCampaignByID(ctx context.Context, id int64) (GetCampaignByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCampaignByID, id)
	var i GetCampaignByIDRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.Visibility,
		&i.Status,
		&i.ActiveSceneID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCampaignIDByMap = `-- name: GetCampaignIDByMap :one
SELECT sc.campaign_id
FROM maps m
JOIN scenes sc ON sc.id = m.scene_id
WHERE m.id = ?
`

func (q *Queries) GetCampaignIDByMap(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCampaignIDByMap, id)
	var campaign_id int64
	err := row.Scan(&campaign_id)
	return campaign_id, err
}

const getCampaignOwner = `-- name: GetCampaignOwner :one
SELECT owner_id
FROM campaigns
WHERE id = ?
`

func (q *Queries) GetCampaignOwner(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCampaignOwner, id)
	var owner_id int64
	err := row.Scan(&owner_id)
	return owner_id, err
}

const getCharacterByIDAndUser = `-- name: GetCharacterByIDAndUser :one
SELECT id, user_id, name, race, class, level, COALESCE(background, '') as background, COALESCE(alignment, '') as alignment, COALESCE(experience_points, 0) as experience_points,
       strength, dexterity, constitution, intelligence, wisdom, charisma,
       max_hp, current_hp, COALESCE(temp_hp, 0) as temp_hp, armor_class, COALESCE(speed, 0) as speed, COALESCE(hit_dice, '') as hit_dice,
       COALESCE(skill_proficiencies, '[]') as skill_proficiencies, COALESCE(saving_throw_proficiencies, '[]') as saving_throw_proficiencies, COALESCE(features, '[]') as features, COALESCE(equipment, '[]') as equipment,
       COALESCE(avatar_url, '') as avatar_url, created_at, updated_at
FROM characters
WHERE id = ? AND user_id = ?
`

type GetCharacterByIDAndUserParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"userId"`
}

type GetCharacterByIDAndUserRow struct {
	ID                       int64     `json:"id"`
	UserID                   int64     `json:"userId"`
	Name                     string    `json:"name"`
	Race                     string    `json:"race"`
	Class                    string    `json:"class"`
	Level                    int64     `json:"level"`
	Background               string    `json:"background"`
	Alignment                string    `json:"alignment"`
	ExperiencePoints         int64     `json:"experiencePoints"`
	Strength                 int64     `json:"strength"`
	Dexterity                int64     `json:"dexterity"`
	Constitution             int64     `json:"constitution"`
	Intelligence             int64     `json:"intelligence"`
	Wisdom                   int64     `json:"wisdom"`
	Charisma                 int64     `json:"charisma"`
	MaxHp                    int64     `json:"maxHp"`
	CurrentHp                int64     `json:"currentHp"`
	TempHp                   int64     `json:"tempHp"`
	ArmorClass               int64     `json:"armorClass"`
	Speed                    int64     `json:"speed"`
	HitDice                  string    `json:"hitDice"`
	SkillProficiencies       string    `json:"skillProficiencies"`
	SavingThrowProficiencies string    `json:"savingThrowProficiencies"`
	Features                 string    `json:"features"`
	Equipment                string    `json:"equipment"`
	AvatarUrl                string    `json:"avatarUrl"`
	CreatedAt                time.Time `json:"createdAt"`
	UpdatedAt                time.Time `json:"updatedAt"`
}

func (q *Queries) GetCharacterByIDAndUser(ctx context.Context, arg GetCharacterByIDAndUserParams) (GetCharacterByIDAndUserRow, error) {
	row := q.db.QueryRowContext(ctx, getCharacterByIDAndUser, arg.ID, arg.UserID)
	var i GetCharacterByIDAndUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Race,
		&i.Class,
		&i.Level,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHp,
		&i.CurrentHp,
		&i.TempHp,
		&i.ArmorClass,
		&i.Speed,
		&i.HitDice,
		&i.SkillProficiencies,
		&i.SavingThrowProficiencies,
		&i.Features,
		&i.Equipment,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCharacterOwner = `-- name: GetCharacterOwner :one
SELECT user_id
FROM characters
WHERE id = ?
`

// Utility queries
func (q *Queries) GetCharacterOwner(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCharacterOwner, id)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const getFirstSceneByCampaignID = `-- name: GetFirstSceneByCampaignID :one
SELECT id FROM scenes WHERE campaign_id = ? ORDER BY ordering ASC, id ASC LIMIT 1
`

func (q *Queries) GetFirstSceneByCampaignID(ctx context.Context, campaignID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFirstSceneByCampaignID, campaignID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getInviteByCode = `-- name: GetInviteByCode :one
SELECT id, campaign_id, code, invited_by, role_default, status, expires_at, redeemed_by, redeemed_at, created_at
FROM campaign_invites
WHERE code = ?
`

func (q *Queries) GetInviteByCode(ctx context.Context, code string) (CampaignInvite, error) {
	row := q.db.QueryRowContext(ctx, getInviteByCode, code)
	var i CampaignInvite
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Code,
		&i.InvitedBy,
		&i.RoleDefault,
		&i.Status,
		&i.ExpiresAt,
		&i.RedeemedBy,
		&i.RedeemedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getMemberSummary = `-- name: GetMemberSummary :one
SELECT m.id, m.campaign_id, m.user_id, u.username, m.role, m.status, COALESCE(m.invited_by, 0) as invited_by, m.created_at
FROM campaign_members m
JOIN users u ON u.id = m.user_id
WHERE m.campaign_id = ? AND m.user_id = ?
`

type GetMemberSummaryParams struct {
	CampaignID int64 `json:"campaignId"`
	UserID     int64 `json:"userId"`
}

type GetMemberSummaryRow struct {
	ID         int64     `json:"id"`
	CampaignID int64     `json:"campaignId"`
	UserID     int64     `json:"userId"`
	Username   string    `json:"username"`
	Role       string    `json:"role"`
	Status     string    `json:"status"`
	InvitedBy  int64     `json:"invitedBy"`
	CreatedAt  time.Time `json:"createdAt"`
}

func (q *Queries) GetMemberSummary(ctx context.Context, arg GetMemberSummaryParams) (GetMemberSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getMemberSummary, arg.CampaignID, arg.UserID)
	var i GetMemberSummaryRow
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.UserID,
		&i.Username,
		&i.Role,
		&i.Status,
		&i.InvitedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getMembership = `-- name: GetMembership :one
SELECT role, status
FROM campaign_members
WHERE campaign_id = ? AND user_id = ?
`

type GetMembershipParams struct {
	CampaignID int64 `json:"campaignId"`
	UserID     int64 `json:"userId"`
}

type GetMembershipRow struct {
	Role   string `json:"role"`
	Status string `json:"status"`
}

func (q *Queries) GetMembership(ctx context.Context, arg GetMembershipParams) (GetMembershipRow, error) {
	row := q.db.QueryRowContext(ctx, getMembership, arg.CampaignID, arg.UserID)
	var i GetMembershipRow
	err := row.Scan(&i.Role, &i.Status)
	return i, err
}

const getTokenByID = `-- name: GetTokenByID :one
SELECT id, map_id, COALESCE(character_id, 0) as character_id, label, image_url, size_squares, position_x, position_y, facing_deg, audience, layer, tags, COALESCE(notes, '') as notes, COALESCE(created_by, 0) as created_by, created_at
FROM tokens
WHERE id = ?
`

type GetTokenByIDRow struct {
	ID          int64     `json:"id"`
	MapID       int64     `json:"mapId"`
	CharacterID int64     `json:"characterId"`
	Label       string    `json:"label"`
	ImageUrl    *string   `json:"imageUrl"`
	SizeSquares int64     `json:"sizeSquares"`
	PositionX   int64     `json:"positionX"`
	PositionY   int64     `json:"positionY"`
	FacingDeg   int64     `json:"facingDeg"`
	Audience    string    `json:"audience"`
	Layer       string    `json:"layer"`
	Tags        string    `json:"tags"`
	Notes       string    `json:"notes"`
	CreatedBy   int64     `json:"createdBy"`
	CreatedAt   time.Time `json:"createdAt"`
}

func (q *Queries) GetTokenByID(ctx context.Context, id int64) (GetTokenByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTokenByID, id)
	var i GetTokenByIDRow
	err := row.Scan(
		&i.ID,
		&i.MapID,
		&i.CharacterID,
		&i.Label,
		&i.ImageUrl,
		&i.SizeSquares,
		&i.PositionX,
		&i.PositionY,
		&i.FacingDeg,
		&i.Audience,
		&i.Layer,
		&i.Tags,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, password_hash, created_at
FROM users
WHERE id = ?
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password_hash, created_at
FROM users
WHERE username = ?
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CreatedAt,
	)
	return i, err
}

const insertCampaign = `-- name: InsertCampaign :one
INSERT INTO campaigns (owner_id, name, description, visibility, status, active_scene_id)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, owner_id, name, COALESCE(description, '') as description, visibility, status, active_scene_id, created_at, updated_at
`

type InsertCampaignParams struct {
	OwnerID       int64   `json:"ownerId"`
	Name          string  `json:"name"`
	Description   *string `json:"description"`
	Visibility    string  `json:"visibility"`
	Status        string  `json:"status"`
	ActiveSceneID *int64  `json:"activeSceneId"`
}

type InsertCampaignRow struct {
	ID            int64     `json:"id"`
	OwnerID       int64     `json:"ownerId"`
	Name          string    `json:"name"`
	Description   string    `json:"description"`
	Visibility    string    `json:"visibility"`
	Status        string    `json:"status"`
	ActiveSceneID *int64    `json:"activeSceneId"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

// Campaign queries
func (q *Queries) InsertCampaign(ctx context.Context, arg InsertCampaignParams) (InsertCampaignRow, error) {
	row := q.db.QueryRowContext(ctx, insertCampaign,
		arg.OwnerID,
		arg.Name,
		arg.Description,
		arg.Visibility,
		arg.Status,
		arg.ActiveSceneID,
	)
	var i InsertCampaignRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.Visibility,
		&i.Status,
		&i.ActiveSceneID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertCampaignCharacter = `-- name: InsertCampaignCharacter :one
INSERT INTO campaign_characters (campaign_id, character_id)
VALUES (?, ?)
RETURNING id, campaign_id, character_id, created_at
`

type InsertCampaignCharacterParams struct {
	CampaignID  int64 `json:"campaignId"`
	CharacterID int64 `json:"characterId"`
}

func (q *Queries) InsertCampaignCharacter(ctx context.Context, arg InsertCampaignCharacterParams) (CampaignCharacter, error) {
	row := q.db.QueryRowContext(ctx, insertCampaignCharacter, arg.CampaignID, arg.CharacterID)
	var i CampaignCharacter
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.CharacterID,
		&i.CreatedAt,
	)
	return i, err
}

const insertCampaignInvite = `-- name: InsertCampaignInvite :one
INSERT INTO campaign_invites (campaign_id, code, invited_by, role_default, status, expires_at)
VALUES (?, ?, ?, ?, 'active', ?)
RETURNING id, campaign_id, code, invited_by, role_default, status, expires_at, redeemed_by, redeemed_at, created_at
`

type InsertCampaignInviteParams struct {
	CampaignID  int64     `json:"campaignId"`
	Code        string    `json:"code"`
	InvitedBy   int64     `json:"invitedBy"`
	RoleDefault string    `json:"roleDefault"`
	ExpiresAt   time.Time `json:"expiresAt"`
}

// Invite queries
func (q *Queries) InsertCampaignInvite(ctx context.Context, arg InsertCampaignInviteParams) (CampaignInvite, error) {
	row := q.db.QueryRowContext(ctx, insertCampaignInvite,
		arg.CampaignID,
		arg.Code,
		arg.InvitedBy,
		arg.RoleDefault,
		arg.ExpiresAt,
	)
	var i CampaignInvite
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.Code,
		&i.InvitedBy,
		&i.RoleDefault,
		&i.Status,
		&i.ExpiresAt,
		&i.RedeemedBy,
		&i.RedeemedAt,
		&i.CreatedAt,
	)
	return i, err
}

const insertCampaignMember = `-- name: InsertCampaignMember :one
INSERT INTO campaign_members (campaign_id, user_id, role, status, invited_by)
VALUES (?, ?, ?, ?, ?)
RETURNING id, campaign_id, user_id, role, status, invited_by, created_at
`

type InsertCampaignMemberParams struct {
	CampaignID int64  `json:"campaignId"`
	UserID     int64  `json:"userId"`
	Role       string `json:"role"`
	Status     string `json:"status"`
	InvitedBy  *int64 `json:"invitedBy"`
}

func (q *Queries) InsertCampaignMember(ctx context.Context, arg InsertCampaignMemberParams) (CampaignMember, error) {
	row := q.db.QueryRowContext(ctx, insertCampaignMember,
		arg.CampaignID,
		arg.UserID,
		arg.Role,
		arg.Status,
		arg.InvitedBy,
	)
	var i CampaignMember
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.UserID,
		&i.Role,
		&i.Status,
		&i.InvitedBy,
		&i.CreatedAt,
	)
	return i, err
}

const insertCharacter = `-- name: InsertCharacter :one
INSERT INTO characters (
    user_id, name, race, class, level, background, alignment, experience_points,
    strength, dexterity, constitution, intelligence, wisdom, charisma,
    max_hp, current_hp, temp_hp, armor_class, speed, hit_dice,
    skill_proficiencies, saving_throw_proficiencies, features, equipment,
    avatar_url
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, name, race, class, level, background, alignment, experience_points,
          strength, dexterity, constitution, intelligence, wisdom, charisma,
          max_hp, current_hp, temp_hp, armor_class, speed, hit_dice,
          skill_proficiencies, saving_throw_proficiencies, features, equipment,
          avatar_url, created_at, updated_at
`

type InsertCharacterParams struct {
	UserID                   int64   `json:"userId"`
	Name                     string  `json:"name"`
	Race                     string  `json:"race"`
	Class                    string  `json:"class"`
	Level                    int64   `json:"level"`
	Background               *string `json:"background"`
	Alignment                *string `json:"alignment"`
	ExperiencePoints         *int64  `json:"experiencePoints"`
	Strength                 int64   `json:"strength"`
	Dexterity                int64   `json:"dexterity"`
	Constitution             int64   `json:"constitution"`
	Intelligence             int64   `json:"intelligence"`
	Wisdom                   int64   `json:"wisdom"`
	Charisma                 int64   `json:"charisma"`
	MaxHp                    int64   `json:"maxHp"`
	CurrentHp                int64   `json:"currentHp"`
	TempHp                   *int64  `json:"tempHp"`
	ArmorClass               int64   `json:"armorClass"`
	Speed                    *int64  `json:"speed"`
	HitDice                  *string `json:"hitDice"`
	SkillProficiencies       *string `json:"skillProficiencies"`
	SavingThrowProficiencies *string `json:"savingThrowProficiencies"`
	Features                 *string `json:"features"`
	Equipment                *string `json:"equipment"`
	AvatarUrl                *string `json:"avatarUrl"`
}

func (q *Queries) InsertCharacter(ctx context.Context, arg InsertCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, insertCharacter,
		arg.UserID,
		arg.Name,
		arg.Race,
		arg.Class,
		arg.Level,
		arg.Background,
		arg.Alignment,
		arg.ExperiencePoints,
		arg.Strength,
		arg.Dexterity,
		arg.Constitution,
		arg.Intelligence,
		arg.Wisdom,
		arg.Charisma,
		arg.MaxHp,
		arg.CurrentHp,
		arg.TempHp,
		arg.ArmorClass,
		arg.Speed,
		arg.HitDice,
		arg.SkillProficiencies,
		arg.SavingThrowProficiencies,
		arg.Features,
		arg.Equipment,
		arg.AvatarUrl,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Race,
		&i.Class,
		&i.Level,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHp,
		&i.CurrentHp,
		&i.TempHp,
		&i.ArmorClass,
		&i.Speed,
		&i.HitDice,
		&i.SkillProficiencies,
		&i.SavingThrowProficiencies,
		&i.Features,
		&i.Equipment,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertMembershipOnRedeem = `-- name: InsertMembershipOnRedeem :exec
INSERT INTO campaign_members (campaign_id, user_id, role, status, invited_by)
VALUES (?, ?, ?, 'accepted', ?)
`

type InsertMembershipOnRedeemParams struct {
	CampaignID int64  `json:"campaignId"`
	UserID     int64  `json:"userId"`
	Role       string `json:"role"`
	InvitedBy  *int64 `json:"invitedBy"`
}

func (q *Queries) InsertMembershipOnRedeem(ctx context.Context, arg InsertMembershipOnRedeemParams) error {
	_, err := q.db.ExecContext(ctx, insertMembershipOnRedeem,
		arg.CampaignID,
		arg.UserID,
		arg.Role,
		arg.InvitedBy,
	)
	return err
}

const insertNote = `-- name: InsertNote :one
INSERT INTO notes (user_id, entity_type, entity_id, title, body)
VALUES (?, ?, ?, ?, ?)
RETURNING id, user_id, entity_type, entity_id, title, body, created_at, updated_at
`

type InsertNoteParams struct {
	UserID     int64  `json:"userId"`
	EntityType string `json:"entityType"`
	EntityID   *int64 `json:"entityId"`
	Title      string `json:"title"`
	Body       string `json:"body"`
}

// Notes queries
func (q *Queries) InsertNote(ctx context.Context, arg InsertNoteParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, insertNote,
		arg.UserID,
		arg.EntityType,
		arg.EntityID,
		arg.Title,
		arg.Body,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EntityType,
		&i.EntityID,
		&i.Title,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCampaignDetails = `-- name: ListCampaignDetails :many
SELECT c.id AS campaign_id, c.owner_id, c.name, c.description, c.visibility, c.status, c.active_scene_id, c.created_at, c.updated_at,
       cc.id AS link_id, COALESCE(ch.id, 0) AS character_id, COALESCE(ch.name, '') AS character_name, COALESCE(ch.class, '') AS character_class, COALESCE(ch.level, 0) AS character_level,
       COALESCE(u.id, 0) AS owner_user_id, COALESCE(u.username, '') AS owner_username
FROM campaigns c
JOIN campaign_members m ON m.campaign_id = c.id
LEFT JOIN campaign_characters cc ON cc.campaign_id = c.id
LEFT JOIN characters ch ON ch.id = cc.character_id
LEFT JOIN users u ON u.id = ch.user_id
WHERE m.user_id = ? AND m.status = 'accepted'
ORDER BY c.updated_at DESC, c.id, cc.id
`

type ListCampaignDetailsRow struct {
	CampaignID     int64     `json:"campaignId"`
	OwnerID        int64     `json:"ownerId"`
	Name           string    `json:"name"`
	Description    *string   `json:"description"`
	Visibility     string    `json:"visibility"`
	Status         string    `json:"status"`
	ActiveSceneID  *int64    `json:"activeSceneId"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
	LinkID         *int64    `json:"linkId"`
	CharacterID    int64     `json:"characterId"`
	CharacterName  string    `json:"characterName"`
	CharacterClass string    `json:"characterClass"`
	CharacterLevel int64     `json:"characterLevel"`
	OwnerUserID    int64     `json:"ownerUserId"`
	OwnerUsername  string    `json:"ownerUsername"`
}

func (q *Queries) ListCampaignDetails(ctx context.Context, userID int64) ([]ListCampaignDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCampaignDetails, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCampaignDetailsRow
	for rows.Next() {
		var i ListCampaignDetailsRow
		if err := rows.Scan(
			&i.CampaignID,
			&i.OwnerID,
			&i.Name,
			&i.Description,
			&i.Visibility,
			&i.Status,
			&i.ActiveSceneID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LinkID,
			&i.CharacterID,
			&i.CharacterName,
			&i.CharacterClass,
			&i.CharacterLevel,
			&i.OwnerUserID,
			&i.OwnerUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaignHandouts = `-- name: ListCampaignHandouts :many
SELECT id, campaign_id, title, COALESCE(description, '') as description, COALESCE(file_path, '') as file_path, created_by, created_at, updated_at
FROM campaign_handouts
WHERE campaign_id = ?
ORDER BY created_at DESC, id DESC
`

type ListCampaignHandoutsRow struct {
	ID          int64     `json:"id"`
	CampaignID  int64     `json:"campaignId"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	FilePath    string    `json:"filePath"`
	CreatedBy   int64     `json:"createdBy"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

// Handout queries
func (q *Queries) ListCampaignHandouts(ctx context.Context, campaignID int64) ([]ListCampaignHandoutsRow, error) {
	rows, err := q.db.QueryContext(ctx, listCampaignHandouts, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCampaignHandoutsRow
	for rows.Next() {
		var i ListCampaignHandoutsRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Title,
			&i.Description,
			&i.FilePath,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaignMembers = `-- name: ListCampaignMembers :many
SELECT m.id, m.campaign_id, m.user_id, u.username, m.role, m.status, COALESCE(m.invited_by, 0) as invited_by, m.created_at
FROM campaign_members m
JOIN users u ON u.id = m.user_id
WHERE m.campaign_id = ?
ORDER BY m.created_at ASC
`

type ListCampaignMembersRow struct {
	ID         int64     `json:"id"`
	CampaignID int64     `json:"campaignId"`
	UserID     int64     `json:"userId"`
	Username   string    `json:"username"`
	Role       string    `json:"role"`
	Status     string    `json:"status"`
	InvitedBy  int64     `json:"invitedBy"`
	CreatedAt  time.Time `json:"createdAt"`
}

func (q *Queries) ListCampaignMembers(ctx context.Context, campaignID int64) ([]ListCampaignMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCampaignMembers, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCampaignMembersRow
	for rows.Next() {
		var i ListCampaignMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.UserID,
			&i.Username,
			&i.Role,
			&i.Status,
			&i.InvitedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCampaignsForUser = `-- name: ListCampaignsForUser :many
SELECT c.id, c.owner_id, c.name, COALESCE(c.description, '') as description, c.visibility, c.status, c.active_scene_id, c.created_at, c.updated_at
FROM campaigns c
JOIN campaign_members m ON m.campaign_id = c.id
WHERE m.user_id = ? AND m.status = 'accepted'
ORDER BY c.updated_at DESC
`

type ListCampaignsForUserRow struct {
	ID            int64     `json:"id"`
	OwnerID       int64     `json:"ownerId"`
	Name          string    `json:"name"`
	Description   string    `json:"description"`
	Visibility    string    `json:"visibility"`
	Status        string    `json:"status"`
	ActiveSceneID *int64    `json:"activeSceneId"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

func (q *Queries) ListCampaignsForUser(ctx context.Context, userID int64) ([]ListCampaignsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listCampaignsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCampaignsForUserRow
	for rows.Next() {
		var i ListCampaignsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.Description,
			&i.Visibility,
			&i.Status,
			&i.ActiveSceneID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharactersByUser = `-- name: ListCharactersByUser :many
SELECT id, user_id, name, race, class, level, COALESCE(background, '') as background, COALESCE(alignment, '') as alignment, COALESCE(experience_points, 0) as experience_points,
       strength, dexterity, constitution, intelligence, wisdom, charisma,
       max_hp, current_hp, COALESCE(temp_hp, 0) as temp_hp, armor_class, COALESCE(speed, 0) as speed, COALESCE(hit_dice, '') as hit_dice,
       COALESCE(skill_proficiencies, '[]') as skill_proficiencies, COALESCE(saving_throw_proficiencies, '[]') as saving_throw_proficiencies, COALESCE(features, '[]') as features, COALESCE(equipment, '[]') as equipment,
       COALESCE(avatar_url, '') as avatar_url, created_at, updated_at
FROM characters
WHERE user_id = ?
ORDER BY updated_at DESC
`

type ListCharactersByUserRow struct {
	ID                       int64     `json:"id"`
	UserID                   int64     `json:"userId"`
	Name                     string    `json:"name"`
	Race                     string    `json:"race"`
	Class                    string    `json:"class"`
	Level                    int64     `json:"level"`
	Background               string    `json:"background"`
	Alignment                string    `json:"alignment"`
	ExperiencePoints         int64     `json:"experiencePoints"`
	Strength                 int64     `json:"strength"`
	Dexterity                int64     `json:"dexterity"`
	Constitution             int64     `json:"constitution"`
	Intelligence             int64     `json:"intelligence"`
	Wisdom                   int64     `json:"wisdom"`
	Charisma                 int64     `json:"charisma"`
	MaxHp                    int64     `json:"maxHp"`
	CurrentHp                int64     `json:"currentHp"`
	TempHp                   int64     `json:"tempHp"`
	ArmorClass               int64     `json:"armorClass"`
	Speed                    int64     `json:"speed"`
	HitDice                  string    `json:"hitDice"`
	SkillProficiencies       string    `json:"skillProficiencies"`
	SavingThrowProficiencies string    `json:"savingThrowProficiencies"`
	Features                 string    `json:"features"`
	Equipment                string    `json:"equipment"`
	AvatarUrl                string    `json:"avatarUrl"`
	CreatedAt                time.Time `json:"createdAt"`
	UpdatedAt                time.Time `json:"updatedAt"`
}

// Character queries
func (q *Queries) ListCharactersByUser(ctx context.Context, userID int64) ([]ListCharactersByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharactersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharactersByUserRow
	for rows.Next() {
		var i ListCharactersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Race,
			&i.Class,
			&i.Level,
			&i.Background,
			&i.Alignment,
			&i.ExperiencePoints,
			&i.Strength,
			&i.Dexterity,
			&i.Constitution,
			&i.Intelligence,
			&i.Wisdom,
			&i.Charisma,
			&i.MaxHp,
			&i.CurrentHp,
			&i.TempHp,
			&i.ArmorClass,
			&i.Speed,
			&i.HitDice,
			&i.SkillProficiencies,
			&i.SavingThrowProficiencies,
			&i.Features,
			&i.Equipment,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMapsBySceneIDs = `-- name: ListMapsBySceneIDs :many
SELECT id, scene_id, name, COALESCE(base_image_url, '') as base_image_url, grid_size_ft, CAST(width_px AS INTEGER) as width_px, CAST(height_px AS INTEGER) as height_px, lighting_mode, fog_state, created_at
FROM maps
WHERE scene_id IN (/*SLICE:scene_ids*/?)
ORDER BY id ASC
`

type ListMapsBySceneIDsRow struct {
	ID           int64     `json:"id"`
	SceneID      int64     `json:"sceneId"`
	Name         string    `json:"name"`
	BaseImageUrl string    `json:"baseImageUrl"`
	GridSizeFt   int64     `json:"gridSizeFt"`
	WidthPx      int64     `json:"widthPx"`
	HeightPx     int64     `json:"heightPx"`
	LightingMode string    `json:"lightingMode"`
	FogState     string    `json:"fogState"`
	CreatedAt    time.Time `json:"createdAt"`
}

func (q *Queries) ListMapsBySceneIDs(ctx context.Context, sceneIds []int64) ([]ListMapsBySceneIDsRow, error) {
	query := listMapsBySceneIDs
	var queryParams []interface{}
	if len(sceneIds) > 0 {
		for _, v := range sceneIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:scene_ids*/?", strings.Repeat(",?", len(sceneIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:scene_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMapsBySceneIDsRow
	for rows.Next() {
		var i ListMapsBySceneIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.SceneID,
			&i.Name,
			&i.BaseImageUrl,
			&i.GridSizeFt,
			&i.WidthPx,
			&i.HeightPx,
			&i.LightingMode,
			&i.FogState,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotesForUser = `-- name: ListNotesForUser :many
SELECT n.id, n.user_id, n.entity_type, n.entity_id, n.title, n.body, n.created_at, n.updated_at, NULL AS score
FROM notes n
WHERE n.user_id = ?
  AND (? = '' OR n.entity_type = ?)
  AND (? IS NULL OR n.entity_id = ?)
ORDER BY n.updated_at DESC
LIMIT ?
`

type ListNotesForUserParams struct {
	UserID     int64       `json:"userId"`
	Column2    interface{} `json:"column2"`
	EntityType string      `json:"entityType"`
	Column4    interface{} `json:"column4"`
	EntityID   *int64      `json:"entityId"`
	Limit      int64       `json:"limit"`
}

type ListNotesForUserRow struct {
	ID         int64       `json:"id"`
	UserID     int64       `json:"userId"`
	EntityType string      `json:"entityType"`
	EntityID   *int64      `json:"entityId"`
	Title      string      `json:"title"`
	Body       string      `json:"body"`
	CreatedAt  time.Time   `json:"createdAt"`
	UpdatedAt  time.Time   `json:"updatedAt"`
	Score      interface{} `json:"score"`
}

func (q *Queries) ListNotesForUser(ctx context.Context, arg ListNotesForUserParams) ([]ListNotesForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listNotesForUser,
		arg.UserID,
		arg.Column2,
		arg.EntityType,
		arg.Column4,
		arg.EntityID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotesForUserRow
	for rows.Next() {
		var i ListNotesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.EntityType,
			&i.EntityID,
			&i.Title,
			&i.Body,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScenes = `-- name: ListScenes :many
SELECT id, campaign_id, name, COALESCE(description, '') as description, ordering, is_active, created_by, created_at, updated_at
FROM scenes
WHERE campaign_id = ?
ORDER BY ordering ASC, id ASC
`

type ListScenesRow struct {
	ID          int64     `json:"id"`
	CampaignID  int64     `json:"campaignId"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	Ordering    int64     `json:"ordering"`
	IsActive    bool      `json:"isActive"`
	CreatedBy   *int64    `json:"createdBy"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

func (q *Queries) ListScenes(ctx context.Context, campaignID int64) ([]ListScenesRow, error) {
	rows, err := q.db.QueryContext(ctx, listScenes, campaignID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListScenesRow
	for rows.Next() {
		var i ListScenesRow
		if err := rows.Scan(
			&i.ID,
			&i.CampaignID,
			&i.Name,
			&i.Description,
			&i.Ordering,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokensByMapIDs = `-- name: ListTokensByMapIDs :many
SELECT id, map_id, character_id, label, COALESCE(image_url, '') as image_url, size_squares, position_x, position_y, facing_deg, audience, layer, tags, COALESCE(notes, '') as notes, created_by, created_at
FROM tokens
WHERE map_id IN (/*SLICE:map_ids*/?)
ORDER BY id ASC
`

type ListTokensByMapIDsRow struct {
	ID          int64     `json:"id"`
	MapID       int64     `json:"mapId"`
	CharacterID *int64    `json:"characterId"`
	Label       string    `json:"label"`
	ImageUrl    string    `json:"imageUrl"`
	SizeSquares int64     `json:"sizeSquares"`
	PositionX   int64     `json:"positionX"`
	PositionY   int64     `json:"positionY"`
	FacingDeg   int64     `json:"facingDeg"`
	Audience    string    `json:"audience"`
	Layer       string    `json:"layer"`
	Tags        string    `json:"tags"`
	Notes       string    `json:"notes"`
	CreatedBy   *int64    `json:"createdBy"`
	CreatedAt   time.Time `json:"createdAt"`
}

func (q *Queries) ListTokensByMapIDs(ctx context.Context, mapIds []int64) ([]ListTokensByMapIDsRow, error) {
	query := listTokensByMapIDs
	var queryParams []interface{}
	if len(mapIds) > 0 {
		for _, v := range mapIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:map_ids*/?", strings.Repeat(",?", len(mapIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:map_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTokensByMapIDsRow
	for rows.Next() {
		var i ListTokensByMapIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.MapID,
			&i.CharacterID,
			&i.Label,
			&i.ImageUrl,
			&i.SizeSquares,
			&i.PositionX,
			&i.PositionY,
			&i.FacingDeg,
			&i.Audience,
			&i.Layer,
			&i.Tags,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokensByMapIDsForPlayer = `-- name: ListTokensByMapIDsForPlayer :many
SELECT id, map_id, character_id, label, COALESCE(image_url, '') as image_url, size_squares, position_x, position_y, facing_deg, audience, layer, tags, COALESCE(notes, '') as notes, created_by, created_at
FROM tokens
WHERE map_id IN (/*SLICE:map_ids*/?)
  AND layer != 'gm'
ORDER BY id ASC
`

type ListTokensByMapIDsForPlayerRow struct {
	ID          int64     `json:"id"`
	MapID       int64     `json:"mapId"`
	CharacterID *int64    `json:"characterId"`
	Label       string    `json:"label"`
	ImageUrl    string    `json:"imageUrl"`
	SizeSquares int64     `json:"sizeSquares"`
	PositionX   int64     `json:"positionX"`
	PositionY   int64     `json:"positionY"`
	FacingDeg   int64     `json:"facingDeg"`
	Audience    string    `json:"audience"`
	Layer       string    `json:"layer"`
	Tags        string    `json:"tags"`
	Notes       string    `json:"notes"`
	CreatedBy   *int64    `json:"createdBy"`
	CreatedAt   time.Time `json:"createdAt"`
}

func (q *Queries) ListTokensByMapIDsForPlayer(ctx context.Context, mapIds []int64) ([]ListTokensByMapIDsForPlayerRow, error) {
	query := listTokensByMapIDsForPlayer
	var queryParams []interface{}
	if len(mapIds) > 0 {
		for _, v := range mapIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:map_ids*/?", strings.Repeat(",?", len(mapIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:map_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTokensByMapIDsForPlayerRow
	for rows.Next() {
		var i ListTokensByMapIDsForPlayerRow
		if err := rows.Scan(
			&i.ID,
			&i.MapID,
			&i.CharacterID,
			&i.Label,
			&i.ImageUrl,
			&i.SizeSquares,
			&i.PositionX,
			&i.PositionY,
			&i.FacingDeg,
			&i.Audience,
			&i.Layer,
			&i.Tags,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInviteRedeemed = `-- name: MarkInviteRedeemed :exec
UPDATE campaign_invites
SET redeemed_by = ?, redeemed_at = ?
WHERE id = ?
`

type MarkInviteRedeemedParams struct {
	RedeemedBy *int64     `json:"redeemedBy"`
	RedeemedAt *time.Time `json:"redeemedAt"`
	ID         int64      `json:"id"`
}

func (q *Queries) MarkInviteRedeemed(ctx context.Context, arg MarkInviteRedeemedParams) error {
	_, err := q.db.ExecContext(ctx, markInviteRedeemed, arg.RedeemedBy, arg.RedeemedAt, arg.ID)
	return err
}

const revokeMember = `-- name: RevokeMember :exec
UPDATE campaign_members
SET status = 'revoked'
WHERE campaign_id = ? AND user_id = ?
`

type RevokeMemberParams struct {
	CampaignID int64 `json:"campaignId"`
	UserID     int64 `json:"userId"`
}

func (q *Queries) RevokeMember(ctx context.Context, arg RevokeMemberParams) error {
	_, err := q.db.ExecContext(ctx, revokeMember, arg.CampaignID, arg.UserID)
	return err
}

const updateCampaign = `-- name: UpdateCampaign :one
UPDATE campaigns
SET name = ?, description = ?, visibility = ?, status = ?, active_scene_id = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, owner_id, name, COALESCE(description, '') as description, visibility, status, active_scene_id, created_at, updated_at
`

type UpdateCampaignParams struct {
	Name          string  `json:"name"`
	Description   *string `json:"description"`
	Visibility    string  `json:"visibility"`
	Status        string  `json:"status"`
	ActiveSceneID *int64  `json:"activeSceneId"`
	ID            int64   `json:"id"`
}

type UpdateCampaignRow struct {
	ID            int64     `json:"id"`
	OwnerID       int64     `json:"ownerId"`
	Name          string    `json:"name"`
	Description   string    `json:"description"`
	Visibility    string    `json:"visibility"`
	Status        string    `json:"status"`
	ActiveSceneID *int64    `json:"activeSceneId"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

func (q *Queries) UpdateCampaign(ctx context.Context, arg UpdateCampaignParams) (UpdateCampaignRow, error) {
	row := q.db.QueryRowContext(ctx, updateCampaign,
		arg.Name,
		arg.Description,
		arg.Visibility,
		arg.Status,
		arg.ActiveSceneID,
		arg.ID,
	)
	var i UpdateCampaignRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.Visibility,
		&i.Status,
		&i.ActiveSceneID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCampaignActiveScene = `-- name: UpdateCampaignActiveScene :exec
UPDATE campaigns
SET active_scene_id = ?
WHERE id = ?
`

type UpdateCampaignActiveSceneParams struct {
	ActiveSceneID *int64 `json:"activeSceneId"`
	ID            int64  `json:"id"`
}

func (q *Queries) UpdateCampaignActiveScene(ctx context.Context, arg UpdateCampaignActiveSceneParams) error {
	_, err := q.db.ExecContext(ctx, updateCampaignActiveScene, arg.ActiveSceneID, arg.ID)
	return err
}

const updateCampaignStatus = `-- name: UpdateCampaignStatus :one
UPDATE campaigns
SET status = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, owner_id, name, COALESCE(description, '') as description, visibility, status, active_scene_id, created_at, updated_at
`

type UpdateCampaignStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

type UpdateCampaignStatusRow struct {
	ID            int64     `json:"id"`
	OwnerID       int64     `json:"ownerId"`
	Name          string    `json:"name"`
	Description   string    `json:"description"`
	Visibility    string    `json:"visibility"`
	Status        string    `json:"status"`
	ActiveSceneID *int64    `json:"activeSceneId"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

func (q *Queries) UpdateCampaignStatus(ctx context.Context, arg UpdateCampaignStatusParams) (UpdateCampaignStatusRow, error) {
	row := q.db.QueryRowContext(ctx, updateCampaignStatus, arg.Status, arg.ID)
	var i UpdateCampaignStatusRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.Description,
		&i.Visibility,
		&i.Status,
		&i.ActiveSceneID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacter = `-- name: UpdateCharacter :one
UPDATE characters SET
    name = ?, race = ?, class = ?, level = ?, background = ?, alignment = ?, experience_points = ?,
    strength = ?, dexterity = ?, constitution = ?, intelligence = ?, wisdom = ?, charisma = ?,
    max_hp = ?, current_hp = ?, temp_hp = ?, armor_class = ?, speed = ?, hit_dice = ?,
    skill_proficiencies = ?, saving_throw_proficiencies = ?, features = ?, equipment = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, race, class, level, background, alignment, experience_points,
          strength, dexterity, constitution, intelligence, wisdom, charisma,
          max_hp, current_hp, temp_hp, armor_class, speed, hit_dice,
          skill_proficiencies, saving_throw_proficiencies, features, equipment,
          avatar_url, created_at, updated_at
`

type UpdateCharacterParams struct {
	Name                     string  `json:"name"`
	Race                     string  `json:"race"`
	Class                    string  `json:"class"`
	Level                    int64   `json:"level"`
	Background               *string `json:"background"`
	Alignment                *string `json:"alignment"`
	ExperiencePoints         *int64  `json:"experiencePoints"`
	Strength                 int64   `json:"strength"`
	Dexterity                int64   `json:"dexterity"`
	Constitution             int64   `json:"constitution"`
	Intelligence             int64   `json:"intelligence"`
	Wisdom                   int64   `json:"wisdom"`
	Charisma                 int64   `json:"charisma"`
	MaxHp                    int64   `json:"maxHp"`
	CurrentHp                int64   `json:"currentHp"`
	TempHp                   *int64  `json:"tempHp"`
	ArmorClass               int64   `json:"armorClass"`
	Speed                    *int64  `json:"speed"`
	HitDice                  *string `json:"hitDice"`
	SkillProficiencies       *string `json:"skillProficiencies"`
	SavingThrowProficiencies *string `json:"savingThrowProficiencies"`
	Features                 *string `json:"features"`
	Equipment                *string `json:"equipment"`
	ID                       int64   `json:"id"`
	UserID                   int64   `json:"userId"`
}

func (q *Queries) UpdateCharacter(ctx context.Context, arg UpdateCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, updateCharacter,
		arg.Name,
		arg.Race,
		arg.Class,
		arg.Level,
		arg.Background,
		arg.Alignment,
		arg.ExperiencePoints,
		arg.Strength,
		arg.Dexterity,
		arg.Constitution,
		arg.Intelligence,
		arg.Wisdom,
		arg.Charisma,
		arg.MaxHp,
		arg.CurrentHp,
		arg.TempHp,
		arg.ArmorClass,
		arg.Speed,
		arg.HitDice,
		arg.SkillProficiencies,
		arg.SavingThrowProficiencies,
		arg.Features,
		arg.Equipment,
		arg.ID,
		arg.UserID,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Race,
		&i.Class,
		&i.Level,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHp,
		&i.CurrentHp,
		&i.TempHp,
		&i.ArmorClass,
		&i.Speed,
		&i.HitDice,
		&i.SkillProficiencies,
		&i.SavingThrowProficiencies,
		&i.Features,
		&i.Equipment,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCharacterAvatar = `-- name: UpdateCharacterAvatar :one
UPDATE characters
SET avatar_url = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, race, class, level, background, alignment, experience_points,
          strength, dexterity, constitution, intelligence, wisdom, charisma,
          max_hp, current_hp, temp_hp, armor_class, speed, hit_dice,
          skill_proficiencies, saving_throw_proficiencies, features, equipment,
          avatar_url, created_at, updated_at
`

type UpdateCharacterAvatarParams struct {
	AvatarUrl *string `json:"avatarUrl"`
	ID        int64   `json:"id"`
	UserID    int64   `json:"userId"`
}

func (q *Queries) UpdateCharacterAvatar(ctx context.Context, arg UpdateCharacterAvatarParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, updateCharacterAvatar, arg.AvatarUrl, arg.ID, arg.UserID)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Race,
		&i.Class,
		&i.Level,
		&i.Background,
		&i.Alignment,
		&i.ExperiencePoints,
		&i.Strength,
		&i.Dexterity,
		&i.Constitution,
		&i.Intelligence,
		&i.Wisdom,
		&i.Charisma,
		&i.MaxHp,
		&i.CurrentHp,
		&i.TempHp,
		&i.ArmorClass,
		&i.Speed,
		&i.HitDice,
		&i.SkillProficiencies,
		&i.SavingThrowProficiencies,
		&i.Features,
		&i.Equipment,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberRole = `-- name: UpdateMemberRole :one
UPDATE campaign_members
SET role = ?
WHERE campaign_id = ? AND user_id = ?
RETURNING id, campaign_id, user_id, role, status, invited_by, created_at
`

type UpdateMemberRoleParams struct {
	Role       string `json:"role"`
	CampaignID int64  `json:"campaignId"`
	UserID     int64  `json:"userId"`
}

func (q *Queries) UpdateMemberRole(ctx context.Context, arg UpdateMemberRoleParams) (CampaignMember, error) {
	row := q.db.QueryRowContext(ctx, updateMemberRole, arg.Role, arg.CampaignID, arg.UserID)
	var i CampaignMember
	err := row.Scan(
		&i.ID,
		&i.CampaignID,
		&i.UserID,
		&i.Role,
		&i.Status,
		&i.InvitedBy,
		&i.CreatedAt,
	)
	return i, err
}

const updateTokenLayer = `-- name: UpdateTokenLayer :exec
UPDATE tokens
SET layer = ?
WHERE id = ?
`

type UpdateTokenLayerParams struct {
	Layer string `json:"layer"`
	ID    int64  `json:"id"`
}

func (q *Queries) UpdateTokenLayer(ctx context.Context, arg UpdateTokenLayerParams) error {
	_, err := q.db.ExecContext(ctx, updateTokenLayer, arg.Layer, arg.ID)
	return err
}

const updateTokenPosition = `-- name: UpdateTokenPosition :exec
UPDATE tokens
SET position_x = ?, position_y = ?
WHERE id = ?
`

type UpdateTokenPositionParams struct {
	PositionX int64 `json:"positionX"`
	PositionY int64 `json:"positionY"`
	ID        int64 `json:"id"`
}

func (q *Queries) UpdateTokenPosition(ctx context.Context, arg UpdateTokenPositionParams) error {
	_, err := q.db.ExecContext(ctx, updateTokenPosition, arg.PositionX, arg.PositionY, arg.ID)
	return err
}

const upsertMembershipOnRedeem = `-- name: UpsertMembershipOnRedeem :exec
UPDATE campaign_members
SET role = ?, status = 'accepted'
WHERE campaign_id = ? AND user_id = ?
`

type UpsertMembershipOnRedeemParams struct {
	Role       string `json:"role"`
	CampaignID int64  `json:"campaignId"`
	UserID     int64  `json:"userId"`
}

func (q *Queries) UpsertMembershipOnRedeem(ctx context.Context, arg UpsertMembershipOnRedeemParams) error {
	_, err := q.db.ExecContext(ctx, upsertMembershipOnRedeem, arg.Role, arg.CampaignID, arg.UserID)
	return err
}
